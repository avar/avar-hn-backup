{
  "by" : "avar",
  "id" : 11513000,
  "kids" : [ 11513081 ],
  "parent" : 11512916,
  "text" : "<p><pre><code>    &gt; I just read about O_APPEND and it doesn&#x27;t sound like what I&#x27;m\n    &gt; talking about at all. It always appends to the end. It sounds like\n    &gt; if two writers race, both chunks of new data are appended. That&#x27;s\n    &gt; not as useful as what I described. I&#x27;m basically talking about\n    &gt; compare and swap, except instead of compare and swap its compare and\n    &gt; append\n</code></pre>\nCorrect. If you want to only write to the end of a file if that file\nis size X you&#x27;d either need your proposed syscall of &quot;only write if\nsize is X&quot; or have every writer cooperate via flock() to achive that\nvia current semantics.<p>That&#x27;s not at all what the grandparent is talking about though. They\njust want &quot;log&quot; files where you can only append and the write() is\natomic. That doesn&#x27;t mean &quot;my write shouldn&#x27;t work if there is a\nconcurrent write&quot; which is a semantic you&#x27;re making up, and which I\ndon&#x27;t really see making sense for log files.<p>I&#x27;m really finding it difficult to imagine a plausable use case for\nyour proposed semantics. Imagine this: You have 100 concurrent web\nserving processes all writing to an access.log, currently they can\njust write() O_APPEND to an access.log with a string below PIPE_BUF\nand their writes will end up on disk, but may not be interleaved in\n&quot;real time&quot;, but who cares?<p>What you&#x27;re proposing means that only 1 out of those 100 processes\nwill succeed in their write() call. The rest will start a retry loop\nthat&#x27;s trying to write out some data whose order didn&#x27;t even matter in\nthe first place to try to flush it to disk because they all want to\nonly write the data if the size of the file is N, and every single\nwrite updates N.<p>If you have a use-case for strictly serializing writes to disk like\nthis that&#x27;s fine, but it&#x27;s not the common case with log files, and the\nway it&#x27;s done is not to try to add a new API to the kernel, you just\nsend messages to some userspace thread that queues them up and does\nthe I&#x2F;O for you.",
  "time" : 1460854372,
  "type" : "comment"
}
