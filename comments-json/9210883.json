{
  "by" : "avar",
  "id" : 9210883,
  "kids" : [ 9210969 ],
  "parent" : 9210322,
  "text" : "Exactly-once is possible in practice if you effectively bring the client under the umbrella of your transactions. E.g. you can (ab)use MySQL and other RDBMs to do something like:<p>1. Have a table where each row is a &quot;job&quot; or &quot;message&quot; and has a status which when enqueued is status = &quot;unclaimed&quot;. You can also have a `last_changed` column.<p>2. Have workers consuming that table that GET_LOCK() a row and set status = &quot;processing&quot; and hold the lock for the duration of the processing.<p>3. When they&#x27;re finished with the task they update status = &quot;finished&quot; and unlock the row (or equivalently, disconnect).<p>This requires much tighter coupling between the queue and the queue consumer (each client must maintain a lock &#x2F; connection for the duration of processing items).<p>But it means that:<p>* Nothing will ever pick up the item more than once due to the GET_LOCK().<p>* If the consumer dies the item is either just unlocked, or the status is &quot;processing&quot;. You can as a matter of policy re-pick up &quot;processing&quot; with a `last_changed` in the distant past, alert on those items and manually inspect them.<p>* If the consumer processes the item successfully it&#x27;ll set the status to &quot;finished&quot; and nothing will process the item again.<p>Now obviously this requires a lot more overhead &amp; maintenance than what you have in mind, in particular it makes some of the failure cases be &quot;the item is delayed due to a consumer dying and won&#x27;t be processed until a human looks at whether it was actually finished&quot;.<p>But this is the sort of pattern that you might use e.g. if you have a queue for sending out invoices. At work we use MySQL + <a href=\"https://metacpan.org/pod/Data::Consumer::MySQL\" rel=\"nofollow\">https:&#x2F;&#x2F;metacpan.org&#x2F;pod&#x2F;Data::Consumer::MySQL</a> to do this.",
  "time" : 1426505853,
  "type" : "comment"
}
