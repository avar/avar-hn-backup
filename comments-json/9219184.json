{
  "by" : "avar",
  "id" : 9219184,
  "parent" : 9210969,
  "text" : "Right, you don&#x27;t <i>have</i> to implement it like that, but the point is that the job is guaranteed to be in one of these states:<p>* Hasn&#x27;t been picked up yet\n * Has been picked up, and currently has something processing it (because the lock is still there)\n * Has been picked up, but whatever picked it up has gone away\n * It&#x27;s finished<p>Handling the jobs that haven&#x27;t been picked up yet or are finished is easy. But what do you do about the jobs where the processor has simply gone away?<p>Well, if they still hold the lock you can give them some more time, and if they don&#x27;t hold the lock presumably they died.<p>At that point you can decide how you want to handle that, do you just have something re-queue those jobs after some set amount of time has passed, or does someone manually look at the jobs and decide what to do?<p>As an example of something we use this for: You might have some transactional E-Mails to be sent out, each recipient is a row in the queue table, you have to generate an E-Mail and pipe it to sendmail, just before you shell out to sendmail you mark the item as &quot;processing&quot;, then you depending on the sendmail return value you either mark the item as processed in the queue or re-queue it.<p>There&#x27;s obviously a race condition here where sendmail might have returned OK to you but the DB server you&#x27;re talking to blows up (so you can&#x27;t set the status as &quot;finished&quot;). No amount of having unique IDs in external systems is going to help you because that&#x27;ll just create the same problem. I.e. you have some state outside of your system that needs to be manipulated exactly once, and once that&#x27;s done you&#x27;d like to mark the job as done.<p>In practice once you get the things that can fail between &quot;processing&quot; and &quot;finished&quot; down to some trivial logic this sort of thing is <i>really</i> reliable as an &quot;exactly once&quot; queue. To the extent that it fails once in a blue moon you can usually just manually repair it, i.e. in this case see what your mail logs say about what mails you sent out.<p>Redis obviously doesn&#x27;t have the same strong storage guarantees as a disk-backed RDMBs, but we also have a version of exactly this logic that runs on top of Redis sentinel: <a href=\"https://metacpan.org/pod/Queue::Q::ReliableFIFO::Redis\" rel=\"nofollow\">https:&#x2F;&#x2F;metacpan.org&#x2F;pod&#x2F;Queue::Q::ReliableFIFO::Redis</a><p>It has the same queued&#x2F;in-progress&#x2F;finished queues using Redis lists, things are moved between the lists atomically and processed by workers, but of course if a worker crashes and burns at the wrong time you&#x27;re stuck with some items in in-progress state and have to somehow figure out what to do with them. I.e. either you blindly re-queue them (at least once) or manually see whether they finished their work and re-queue them as appropriate (exactly once).",
  "time" : 1426610477,
  "type" : "comment"
}
