{
  "by" : "avar",
  "id" : 5928447,
  "kids" : [ 5928495, 5928561 ],
  "parent" : 5928149,
  "text" : "We&#x27;ve been working on moving away from rsync for our code syncing to\nusing Git where I work.<p>I&#x27;m not saying there aren&#x27;t uses for rsync, but your dismissal of git\nas not being suitable for a &quot;true production deployment system&quot; isn&#x27;t\nsupported in any way. And stating that rsync was &quot;specifically made\nfor this kind of thing&quot; without comparing any of the trade-offs\ninvolved is just appealing to authority.<p>Some things you may have not considered:<p><pre><code>  * rsync is meant to sync up *arbitrary filesystem trees*, whereas\n   with Git you&#x27;re snapshotting trees over time.\n\n   When you transfer content between two Git repositories the two ends\n   can pretty much go &quot;my tree is at X, you have Y, give me X..Y\n   please&quot;. You get that as a pack, then just unpack it in the\n   receiving repository.\n\n   Whereas with rsync even if you don&#x27;t checksum the files you still\n   have to recursively walk the full depth of the tree at both ends\n   (if you&#x27;re doing updates), send that over the wire etc. before you\n   even get to transferring files.\n\n * Since syncing commits and actually checking them out are two\n   different steps you can push out commits (without checking them\n   out!) to your production machines as they&#x27;re pushed to your\n   development branches.\n\n   Then deploying is just sending a message saying &quot;please check out\n   such-and-such SHA1&quot; and the content will already be there!\n\n * You mentioned in another post here that rsync has --delay-updates,\n   this is just like &quot;git reset --hard&quot; (but I&#x27;ll bet Git&#x27;s is more\n   efficient). With Git you can do the transfer of the objects and the\n   checking out of the objects as separate steps.\n\n * It&#x27;s way easier for compliance&#x2F;validation reasons to not get the\n   data out of Git, since you can validate with absolute certainty\n   that what you have at a given commit is what you have deployed\n   (just run &quot;git show&quot;). If you check the files out and then sync\n   them with some out-of-bound mechanism you&#x27;re back to comparing\n   files.\n</code></pre>\nEdit: One thing I forgot, it&#x27;s distributed. Which gives you a lot of\nbenefits. Consider this problem, you have 1000 servers running your\ncode and you&#x27;ve decided that you want to deploy <i>now</i> from a staging\nserver.<p>Having trying to rsync to 1000 servers at once from one box (the na√Øve\nimplementation with rsync) would take forever and overload that one\nbox, especially if you wanted to take advantage of pre-syncing things\non every commit so the commit will already be there if you want to\nroll out (constant polling and&#x2F;or pushing).<p>You can mitigate this by having intermediate servers you push to, but\nthen you&#x27;ve just partitioned the problem, what if you need to swap out\nthose boxes, they go down etc.<p>With Git you can just configure each of the 1000 boxes to have 3 other\nboxes in the pool as a remote. Then you seed one of them with the\ncommit you want to rollout. The content will trickle through the graph\nof machines, any one machine going down will be handled gracefully,\nand if you want to rollout you can just block on something that asks\n&quot;do you have this SHA1 yet&quot; returning true for all live machines\nbefore you &quot;git reset --hard&quot; to that SHA1 everywhere.",
  "time" : 1372008678,
  "type" : "comment"
}
